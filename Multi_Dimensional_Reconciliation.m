function l = Multi_Dimensional_Reconciliation(d,C,X,Y,EsN0dB,k)
%This function simulates the first step of the reconciliation, where Bob
%modulates a randomly generated bit string into his received quadratures
%and transmits them to Alice. 
%d: The dimension of the reconciliation, only d=1,2,4,8 is supported
%C: The codeword Bob wants to share with Alice
%X: The quadratures generated by Alice, with distribution N(0,1)
%Y: The quadratures measured by Bob, with distribution N(0,1+1/(10^(EsN0dB/10))^2)
%EsN0dB: The signal to noise ratio in dB
%k: The repetition factor, which is the (rate of a general ldpc code)/(rate of the code you want)
EsN0 = 10^(EsN0dB/10)*k;
N = length(C);
X_k = zeros([N k]);
Y_k = zeros([N k]);
for i = 1:k
    X_k(:,i) = X(i:k:end);
    Y_k(:,i) = Y(i:k:end);
end
X_abs_avg = 1/k*sum(abs(X_k),2);
switch d
    case 1
        U = (-1).^C;
        M = U.*Y_k;
        R = M./X_k;
        R = 1/k*sum(R,2);
        Sigma2_Nv = 1./(EsN0*(X_abs_avg).^2); 
    case 2
        U = (-1).^C(1:2:end) + 1i*(-1).^C(2:2:end);
        Y_C = Y(1:2:end) + 1i*Y(2:2:end);
        X_C = X(1:2:end) + 1i*X(2:2:end);
        M = U.*Y_C;
        R = M./X_C;
        R = reshape([real(R) imag(R)]',[N 1]);
        Sigma2_Nv = reshape(repmat(2./(EsN0*abs(X_C).^2)',[2 1]), [N 1]);
    case 4
        U = [(-1).^C(1:4:end) (-1).^C(2:4:end) (-1).^C(3:4:end) (-1).^C(4:4:end)];
        Y_Q = [Y(1:4:end) Y(2:4:end) Y(3:4:end) Y(4:4:end)];
        X_Q = [X(1:4:end) X(2:4:end) X(3:4:end) X(4:4:end)];
        X_Q_inv = [X_Q(:,1) -X_Q(:,2) -X_Q(:,3) -X_Q(:,4)]./sum(X_Q.^2,2);
        M = Quaternion_mult(U,Y_Q);
        R = Quaternion_mult(M,X_Q_inv);
        R = reshape(R',[N 1]);
        Sigma2_Nv = reshape(repmat(4./(EsN0*sum(X_Q.^2,2))',[4 1]), [N 1]);
    case 8
        U = [(-1).^C(1:8:end) (-1).^C(2:8:end) (-1).^C(3:8:end) (-1).^C(4:8:end) (-1).^C(5:8:end) (-1).^C(6:8:end) (-1).^C(7:8:end) (-1).^C(8:8:end)];
        Y_O = [Y(1:8:end) Y(2:8:end) Y(3:8:end) Y(4:8:end) Y(5:8:end) Y(6:8:end) Y(7:8:end) Y(8:8:end)];
        X_O = [X(1:8:end) X(2:8:end) X(3:8:end) X(4:8:end) X(5:8:end) X(6:8:end) X(7:8:end) X(8:8:end)];
        X_O_inv = [X_O(:,1) -X_O(:,2) -X_O(:,3) -X_O(:,4) -X_O(:,5) -X_O(:,6) -X_O(:,7) -X_O(:,8)]./sum(X_O.^2,2);
        M = Octonion_mult(U,Y_O);
        R = Octonion_mult(M,X_O_inv);
        R = reshape(R',[N 1]);
        Sigma2_Nv = reshape(repmat(8./(EsN0*sum(X_O.^2,2))',[8 1]), [N 1]);
    otherwise
        error('Only d=1,2,4,8 is supported for the reconciliation')
end
l = 2*R./Sigma2_Nv;
end